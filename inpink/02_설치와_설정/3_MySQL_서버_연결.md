# MySQL 서버 연결

1. 우분투 실행　   
　   
　   
2. mysql 실행　   
~~~
sudo systemctl start mysql
~~~
sudo와 systemctl을 이용하여 mysql를 실행한다. 　   
　   
이 명령이 실행된 시점에서 이미 mysql은 실행되어 있다.　    
우분투에서 접속을 해서 mysql을 사용할 수 있다.　   
아직은 접속하지 않은 상태이다.　   
　   
　   
3. 시작된 mysql 서버 상태 확인　   
~~~
sudo systemctl status mysql
~~~
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/823bc0e8-7f44-4a4a-9f15-5bf917a257ca)
위와 같이 초록 불이 켜져있으면 mysql 서버가 켜져 있다는 뜻이다.　   
    　   
　   
　   
4. mysql 접속　   
~~~
sudo /usr/bin/mysql -u root -p
~~~
이제부터, linux> 라고 떴던 shell에서 　   
mysql> 이라는 shell로 바뀌며  mysql을 사용한다.　   

　   
💬 코드를 조금 더 분석해보자.　   
　   
💙sudo　   
 : 리눅스에서 sudo는 "Superuser Do"의 약자로,　   
 사용자가 슈퍼유저(root) 또는 다른 특정 사용자의 권한을 사용하여 명령어나 프로그램을 실행할 수 있게 해주는 명령어다.　   
 슈퍼유저는 시스템 전체에 대한 제한 없는 권한을 가진 특별한 사용자 계정이며, sudo를 사용하면 보안과 권한 관리를 효과적으로 관리할 수 있다.　   
　   
💙/usr/bin/mysql 　   
: 리눅스에서 우리가 실행하려는 mysql가 있는 위치　   
　   
💙 -u　   
 : 이 옵션은 사용자 이름을 지정한다. 　   
 root는 사용자 이름으로, 보통 MySQL 데이터베이스 서버에 대한 최상위 권한을 가진 사용자인 "root" 사용자를 나타낸다.　    
 (실제로 mysql에서 user를 조회하면 최상위 권한을 가진 root라는 이름의 user가 있다.)　   
 사용자 이름을 지정하여 해당 사용자로 로그인할 수 있다.　   
 　   
💙 -p　   
: 이 옵션은 비밀번호를 입력할 것임을 나타낸다.　   
MySQL에 로그인할 때 비밀번호를 사용자로부터 입력받도록 한다.　   
-p 옵션을 사용하면 MySQL 클라이언트가 비밀번호를 요청한다는 것이다.　   
　   
　   
따라서 -u root -p를 사용하면 MySQL 데이터베이스 서버에 "root" 사용자로 로그인하고　   
해당 사용자의 비밀번호를 입력할 수 있게 된다.　   
이를 통해 MySQL 서버에 대한 권한 있는 작업을 수행할 수 있다.　   
　   
　   
💬 MySQL서버에 접속하는 다른 방법들도 알아보자.　   
　   
~~~
linux> mysql -u root -p --host=localhost --socket=/tmp/mysql.sock
~~~
위와 같이 host와, socket을 지정해줄 수도 있다. 　   
지정해주지 않으면 default로 호스트는 localhost, 소켓 파일은 **MySQL 서버의 설정 파일에 저장된 위치**를 참고해서 소켓을 넣어 사용한다.　   
　   
　   
　   
5. 성공적으로 접속되었다면, 　   
쉘에 mysql > 라고 뜨며 리눅스에서 mysql 서버를 사용할 수 있다. 　   
　   
　   
　   
6. 실행중인 mysql 서버 종료　   
~~~
sudo systemctl stop mysql
~~~
　   
💬 우분투에서는 mysqld말고 mysql으로 사용해야 한다.　   
(책에는 mysqld라고 되어있지만)　   
　   
　   
　   
7. 우분투 재시작 시, 항상 mysql도 자동으로 재시작하도록　   
~~~
sudo systemctl enable mysql
~~~
우분투를 켰을 때 start mysql를 해주지 않아도 자동으로 켜진다.　   
    
　   
　   
8. mysql 서버 재시작　   
~~~
sudo systemctl restart mysql
~~~
　   
　   
　   
9. 클린 셧다운(Clean shutdown)　   
MySQL은 **트랜잭션**이라는 개념을 사용한다.　   
클린 셧다운에 대해 알아보기 전에, 트랜잭션에 대한 이해를 먼저 하도록 하자.　   
　   
💬 트랜잭션　   
트랜잭션은 하나 이상의 SQL 명령어를 묶은 "논리적인" 작업의 단위이다.　   
트랜잭션은 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)이라는 ACID 속성을 보장해야 한다.　   
이러한 ACID 속성은 데이터베이스의 무결성과 안정성을 보장하기 위해 중요한 요소이다.　   
　   
🧡 원자성 (Atomicity)　   
: 하나의 트랜잭션 내의 모든 SQL 명령어는 전부 성공하거나, 전부 실패해야 한다.　   
트랜잭션 내의 어떤 하나의 작업이라도 실패하면, 해당 트랜잭션 내의 성공한 명령어들까지 모조리 다 롤백되어 이전 상태로 복원된다.　   
👉 예를 들어 물건 구입을 할 때, 아래가 하나의 논리적 트랜잭션이라고 해보자.　   
1) 구매 비용을 낸다.　   
2) 구매했다는 사실을 DB에 저장한다.　   

    
위의 과정에서 1번은 성공하고 2번은 실패했다고 생각해보자.　   
하나의 트랜잭션인 1,2번을 모두 rollback 해줘야 한다.　   
　   
　   
🧡 일관성 (Consistency)　   
: 트랜잭션이 시작하기 전과 끝난 후에 데이터베이스는 일관된 상태여야 한다. 일관성을 깨뜨리는 트랜잭션은 거부된다. "제약"과도 관련있다.　   
👉 예를 들어 비밀번호 규칙이 "길이가 8 이상" 이라고 하자. 　   
만약 길이가 7인 비밀번호를 가진 user를 추가하는 쿼리문은, 거부되어야 한다.　   
그렇지 않으면 DB의 일관성이 깨지기 때문이다.　   
　   
🧡 고립성 (Isolation)　   
: 여러 트랜잭션이 동시에 실행될 때, 각각의 트랜잭션은 다른 트랜잭션의 작업에 영향을 미치지 않고 독립적으로 실행되는 것처럼 보여야 한다.　   
한 트랜잭션에서 다른 트랜잭션의 변경 사항을 볼 수 없으며,　   
트랜잭션들은 연속적으로 실행된다는 뜻이다.　   
👉 예를 들어 1인당 1개만 구매할 수 있는 물건이 있다.　   
어떤 사용자가 동시에 1개를 구매하는 요청을 2개 보냈다고 해서, 2개가 다 구매되지 않는다.　   
1개를 구매한 후, 그 다음 1개는 거부하는 트랜잭션의 "연속적인 작업"이 일어난다.　   
　   
　   
🧡 지속성 (Durability)　   
: 트랜잭션이 성공적으로 완료되면 그 결과는 "영구적"으로 저장되어야 한다.　   
시스템 장애 또는 전원 장애가 발생해도 트랜잭션의 결과가 유지되어야 한다.　   
　   
　   
💬트랜잭션 사용 예시　   
　   
① 트랜잭션 시작　   
~~~
START TRANSACTION;
~~~
　   
② SQL 작업 수행 (INSERT, UPDATE, DELETE 등)　   
하나의 트랜잭션을 위한 데이터베이스 작업을 수행한다. 이때 트랜잭션은 아직 커밋되지 않은 상태다.　   
~~~
INSERT INTO employees (employee_id, first_name, last_name) VALUES (101, 'John', 'Doe');
UPDATE employee_salary SET salary = 60000 WHERE employee_id = 101;
~~~
　   
③ 트랜잭션 커밋　   
하나의 트랜잭션을 위한 모든 SQL 작업이 성공적으로 완료되면, 트랜잭션을 커밋하여 변경 사항을 "영구적으로" 데이터베이스에 적용한다.　   
커밋된 상태에서는 데이터의 무결성을 위해 커밋하기 전으로 되돌리는 것이 어렵다. 　   
다시 데이터를 수정해서 커밋해줘야 한다.　   
~~~
COMMIT;
~~~
　   
④ 트랜잭션 롤백　   
만약 오류가 발생하거나 커밋되지 않은 트랜잭션을 취소해야 할 경우, 롤백을 사용하여 "해당 하나의 트랜잭션을 실행하기 전" 이전 상태로 복원한다.　   
~~~
ROLLBACK;
~~~
　   
　   
💬 클린 셧다운　   
MySQL 서버에서는 실제 트랜잭션이 정상적으로 Commit 되어도, **데이터 파일**에는 변경된 내용이 기록되지 않을 수 있다.　   
그럼에도 **로그 파일(Redo log)**에는 저장되어 있는데,　   
　   
MySQL은 어떤 비정상적인 상황에서도 트랜잭션이 영구적으로 보존될 수 있도록 "Redo log"라고 하는 트랜잭션 로그를 가지고 있기 때문이다. 　   
이 트랜잭션 로그를 이용해서, 데이터 변경이 발생했을 때 즉시 그 변경 내용을 "데이터 파일"에 기록하지 않아도 ACID를 보장할 수 있다.   
클린 셧다운을 사용하지 않은 상태에서 MySQL이 종료될 때, 　   
데이터 파일로 기록되지 못한 모든 작업 내용은 **InnoDB의 시스템 테이블스페이스와 트랜잭션 로그 파일**에 남아 있다.　   
MySQL이 다시 시작되면서 InnoDB 스토리지 엔진은 트랜잭션 로그와 데이터 파일의 동기화 여부 (체크포인트 지점)를 확인해서,　   
재시작 전에 마무리되지 못한 작업들을 **Foreground 또는 Background**로 진행하게 된다.　   
일부 작업은 Foreground로 진행되며, 이 작업 도중에서 InnoDB가 **사용 불가능**한 상태가 된다.　   
나머지 작업들은 Background로 진행되는데, 이 과정은 언제 완료될지 아무도 모르고 이 작업이 진행되는 중에서 사용자가 접속해서 쿼리를 실행할 수 있다.　   
[출처](http://intomysql.blogspot.com/2010/12/mysqlinnodb-clean-shutdown.html)　   
　   
　   
그래서 심지어 MySQL 서버가 종료되고 다시 시작된 이후에도 계속 데이터 파일에 기록되지 않을 수 있다는 것이다.　   
사용량이 많은 MySQL 서버에서는 이런 현상이 일반적이다.　   
원한다면, MySQL 서버가 종료될 때, **모든 커밋된 내용을 "데이터 파일"에 기록하고 종료하도록** 설정해줄 수 있다. 이를 "클린 셧다운"이라고 한다.　   
아래 코드를 참고하자. 　   
~~~
mysql> SET GLOBAL innodb_fast_shutdown=0;
~~~
0이 클린 셧다운, 1이 기존의 빠른 종료이다.　   
　   
클린 셧다운으로 종료되면, MySQL가 실행될 때 별도의 **트랜잭션 복구 과정**을 실행하지 않기 때문에 "실행" 속도가 빨라질 수 있다.　   
　   
　   
Q. 적용되지 않은 이전의 데이터를 사용하여 문제가 생기는 일은 왜 없을까?　   
=> 4장에서 학습하게 된다. 간략하게 설명하자면, 데이터 파일에 바로 적용되지 않더라도 Redo Log 등을 이용하여 업데이트된 데이터로 가져올 수 있다. (4_5장 참고!) 　   
　   
　   
　   
　   
11. MySQL를 직접 로그인하지 않고, **원격 서버**에서 MySQL 서버의 접속 가능 여부만 확인하기　   
　   
때로는 직접 로그인하지 않고, 커넥션만 확인하기가 필요할 때가 있다.　   
MySQL 클라이언트를 설치하기 어려운 환경이 이에 포함된다.　   
　   
ⓐ Telnet 이용　   
~~~
linux> telnet 10.2.40.61 3306
~~~
호스트, 소켓　   
　   
ⓑ Netcat 이용 　   
~~~
linux> nc 10.2.40.61 3306
~~~
　   　   
정상적으로 접속된다면,　   
서버가 보내준 메세지가 출력된다.　   
글자가 깨진 메세지가 도착할 수도 있지만, 어쨌든 네트워크 수준의 연결은 정상적임을 판단할 수 있다.　   
