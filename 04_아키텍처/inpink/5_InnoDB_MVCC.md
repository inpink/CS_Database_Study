# InnoDB MVCC(Multi Version Concurrency Control)
　   
2_3장에서 나왔던 질문을 다시 떠올려보자.　   
**변경된 테이블 값이, 즉시 디스크 저장공간으로 반영되지 않을 수 있다고 했다.**　   
[2_3장](https://github.com/inpink/CS_Database_Study/blob/main/02_%EC%84%A4%EC%B9%98%EC%99%80_%EC%84%A4%EC%A0%95/inpink/3_MySQL_%EC%84%9C%EB%B2%84_%EC%97%B0%EA%B2%B0.md)　   
　   
그럼에도, SELECT 등으로 값을 조회하면 변경된 값으로 잘 조회가 된다.　   
위의 내용은 **COMMIT 후에도** 즉시 디스크 저장공간으로 반영되지 않을 수 있다는 것이다.　   
　   
뿐만 아니라, **트랜잭션이 끝나지 않아 COMMIT하기 전에도** 변경된 값이 조회된다.　   
=> 이는 MySQL InnoDB에서 **MVCC(Multi Version Concurrency Control)** 등을 사용하기 때문이다.　   
   어떻게 이럴 수 있는 지 자세히 알아보도록 하자.　   
　   
　   
> MVCC(Multi Version Concurrency Control)

MVCC의 가장 큰 목적은, **잠금을 사용하지 않는 일관된 읽기**를 제공하는 것이다.　   
이는 **언두 로그(Undo log)** 를 이용하여 구현한다. 　   
　   
101p의 그림 4.10와 102p의 그림 4.11을 참고하자.　   
　   
~~~
UPDATE member SET m_area='경기' WHERE m_id=12;
~~~
UPDATE문으로 값이 변하였다.
이 때, **변경된 값은 "InnoDB 버퍼 풀"에 저장된다**
이 때, **변경 전 값만 "Undo Log"로 복사된다.**　   
이 때, **"디스크의 데이터 파일"에는 변경 전 값이 있을지, 변경 후 값이 있을 지는 그때그때 다르다.** 　   
디스크의 데이터 파일에는 **추후 Redo log와 백그라운드 스레드에 의해** 값이 쓰인다.　   
　   
_**아직 트랜잭션이 끝나지 않거나 COMMIT이나 ROLLBACK이 되지 않은 상태에서 값을 조회하면 어떻게 될까?**_　   　   
　   
~~~
SELECT * FROM member WHERE m_id=12;
~~~
=> 이 때도, 변경된 값이 잘 출력된다.　   
　   
**이는, transaction_isolation 시스템 변수의 값에 따라 달라진다.**　   
**격리 수준이 READ_UNCOMMITTED면 변경된 값을 출력하고, 그 이상의 수준인 REPEATABLE_READ, SERIALZABLE인 경우에는 커밋되지 않은 값을 "Undo log"에서 꺼내온다!**　   

이 과정을 MVCC라고 한다. **하나의 레코드(회원 번호가 12인 레코드)에 대해 여러 버전이 유지되고, 필요에 따라 다양한 버전의 데이터가 보여질 수 있다.**　   
**트랜잭션이 길어지면, 언두 로그에 이전 데이터가 많이 쌓이게 될 수 있음을 고려해야 한다.**　   
　   
~~~
COMMIT;
~~~
이 때 COMMIT을 하면 InnoDB는 현재의 **"InnoDB 버퍼 풀"** 에 있는 값을 영구적인 데이터로 만들어버린다.　   
(물론, 언제 디스크에 적용될지는 InnoDB의 엔진 상황에 따라 달라질 것이다.)　   
그렇다고 바로 Undo log에 있는 백업 데이터가 삭제되는 건 아니다. 이 Undo log를 필요로 하는 트랜잭션이 없을 때 삭제된다.　   
　   
~~~
ROLLBACK;
~~~
ROLLBACK을 하면 언두 로그에 있는 데이터를 **"InnoDB 버퍼 풀"** 로 다시 복구한다.　   
　   
　   
=> InnoDB 스토리지 엔진은 MVCC을 이용하여 **항상 잠금을 걸지 않고 읽기**를 수행한다. 　   
   MVCC에서 Undo log를 사용하는 덕분에 **다른 트랜잭션이 A테이블에 대해 작업을 하고 있어도, 내 트랜잭션에서 A테이블의 변경 전(Undo log의) 데이터 읽기가 가능한** 것이다!　   
 🤎장점 : 잠금을 걸지 않았기 때문에, 읽기 작업이 대기나 교착상태에 빠질 일이 없다. 　   
 🤎단점 : 트랜잭션이 길어질 경우, 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 크기가 커진다. 따라서, 트랜잭션의 크기를 적절히 조절하여 가능한 빨리 롤백이나 커밋을 하여 **트랜잭션을 완료해주는 것이 서버의 속도에 도움** 이 된다.　   
　   
　   
> Redo log VS Undo log

💙Redo log　   
  : 트랜잭션이 데이터베이스에 변경 사항을 적용할 때, 해당 **변경 사항**을 먼저 **리두 로그**에 기록한다.　   
  **이후에! 실제 데이터 파일에 변경 사항을 반영** 하는 작업이 수행된다. 　   
  2_3장의 **Clean Shutdown** 을 참고하자.　   
　   
💙Undo log　   
  : 트랜잭션이 **변경 사항을 적용하기 전에 이전 상태**를 저장하여 **롤백 및 동시성 제어**를 지원한다.　   
　   
　   
=> 두 로그 모두! 데이터베이스 시스템의 안정성과 일관성을 유지하는 데 중요한 역할을 한다.　   
**둘 다 중요하고, 두 로그의 차이점을 구분할 수 있어야 한다.** 　   

