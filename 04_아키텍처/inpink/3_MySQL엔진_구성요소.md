# MySQL엔진 구성요소
　   
> 플러그인과 컴포넌트

　   
💙 플러그인　   
MySQL 서버에서는 다양한 기능을 플러그인 형태로 가져와서 사용할 수 있다.　   
검색어 파서, 사용자 인증, 스토리지 엔진 등이 플러그인으로 구현되어 제공된다.　   
각 플러그인 핸들러 API를 구현하면, 사용자나 기업에서 원하는 형태의 플러그인을 만들어 사용할 수도 있다.　   
　   
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/cccecc0f-e7b8-43c6-9b8f-46e00d31b6d9)　   
=> MySQL 서버에 설치되어 있는 플러그인 목록을 확인한다. 　   
　   
　   
💙 컴포넌트　   
MySQL 8.0부터는 플러그인 아키텍처를 **컴포넌트**가 대체한다. 　   
컴포넌트는, 플러그인의 아래 단점들을 보완한다.　   
　   
- 기본적으로 플러그인끼리는 소통이 불가능　   
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출한다. 캡슐화를 하지 않기 때문에, 보안 문제가 있을 수 있다.　   

　   
예) 3장에서 설치해준 "비밀번호 검증 기능(Validate_password)"이 원래는 플러그인 형태로 제공되었지만, MySQL 8.0버전부터 컴포넌트로 바뀌었다.　   
　   
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/d8ee1bab-afe7-408e-b4dd-5184f3eac09c)　   
=> 설치된 모든 컴포넌트를 확인할 수 있다.　   
=> 3장에서 설치해준 validate_password component를 확인할 수 있다.　   
　   
　   
***
　   
> 쿼리 실행 구조

91p 그림 4.6를 참고하자.　   
　   
MySQL 서버는 사용자로부터 SQL 요청을 받아서, MySQL 엔진에게 넘겨준다. 　   
MySQL 엔진은 쿼리를 실행하여 스토리지 엔진에서 데이터를 읽고 저장한다. 그리고, 실행 결과를 반환한다.　   
　   
더 자세한 쿼리 처리 과정을 구성요소의 관점에서 보도록 하자.　   
　   
**MySQL 엔진**은 받은 쿼리를 처리할 때, **쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리실행기**의 단계로 이루어진다.　   

　   
> 쿼리 파서

쿼리를 **토큰**으로 분리해 **트리 형태**로 만든다. 　   
이 때, **쿼리의 문법 오류**를 발견할 수 있다. 　   
　   
예)　   
~~~
SELECT FirstName, LastName FROM Customers WHERE Country = 'USA' AND Age > 30;
~~~
　   
~~~
         SELECT
         /    |    \
  FirstName  ,  LastName
                  |
               FROM
               /   \
       Customers   WHERE
                    /   \
               Country   AND
                        /   \
                     =   Age
                    / \
                 'USA'  >
                           / \
                          30
~~~
　   
　   
　  　    
> 전처리기

파서 트리에 있는 내용 중, 존재하지 않거나 권한상 사용할 수 없는 토큰(테이블 이름, 열 이름, 함수명 등)을 걸러낸다.　   
　   
　   
> 옵티마이저

입력된 SQL 쿼리의 실행 계획을 최적화하여 데이터베이스 성능을 향상시키는 것이 주요 목적이다.　   
저렴한 비용으로 빠르게 처리하기 위한 DBMS의 두뇌에 해당된다.　   
그런 만큼, 옵티마이저의 역할을 중요하고 영향 범위도 매우 넓다.　   
　   
쿼리 분석, 인덱스 선택, 조인 순서 결정, 실행 계획 생성, 동적 최적화, 비용 계산, 실행 계획 선택　   
등의 작업을 한다.　   
　   
하지만 모든 상황에서 옵티마이저가 항상 완벽한 최적화를 보장하는 것은 어려울 수 있기에,　   
때로는 사용자가 직접 SQL 쿼리를 개선하거나 인덱스를 조정하는 등의 작업이 필요하다.　   
　   

　   
> 실행 엔진

MySQL 서버의 각 구성요소들은 핸들러를 통해 요청을 받는다.　   
이 때, **실행 엔진**은 핸들러에서 요청을 전달하고, 핸들러로부터 받은 실행 결과를 다른 핸들러에게 전달하는 역할을 한다. 　   
서로를 연결하는 역할을 맡는다.　   
　   
　   
***
    
> 스레드 풀(Thread Pool)

MySQL의 스레드 풀은 엔터프라이즈 에디션(유료)에서 제공된다.　   
무료 버전에서는 Percona Server에서 제공하는 thread_pool 플러그인을 이용하면 비슷한 기능을 사용할 수 있다.　   
　   
MySQL은 클라이언트 요청을 처리하기 위해 스레드를 사용한다.　   
이전에는 각 클라이언트 연결에 대해 별도의 스레드를 생성하고 소멸시켰으나,　   
스레드 풀은 제한된 개수의 스레드를 관리자가 정할 수 있게 한다.　   
**제한된 개수의 스레드를 CPU가 처리하게 해서 서버의 자원 소모를 줄이는 것**이 큰 목적이다.　   
　   
스레드 풀을 쓴다고 해서 항상 성능이 향상되는 것은 아니다. 　   
오히려 스레드 개수 및 스케쥴링 과정에서 각 작업이 CPU 시간을 제대로 확보하지 못하면, 사용하는 것보다 더 좋지 않은 쿼리 처리 효율을 낼 수 있다.　   
　   
Percona Server의 **스레드 그룹**은 여러 개의 스레드를 논리적으로 묶어 그룹화한 것이다.　   
각 그룹에 대해 서로 다른 스레드 제한과 우선순위를 설정할 수도 있다.　   
이를 통해 작업 부하와 요청 유형에 따라 스레드를 효과적으로 관리하고 자원을 할당할 수 있다.　   
Percona Server의 thread_pool은 thread_pool_size 시스템 변수를 통해 스레드 그룹의 개수를 조정할 수 있다.　   
일반적으로는 스레드 그룹 개수는 CPU 코어의 개수와 같은 개수로 두는 것이 좋다.　   
　   
　   
　   
> CPU 코어 개수

CPU 코어 개수는,　   
컴퓨터의 중앙 처리 장치인 CPU(Central Processing Unit)에 포함된 **물리적인 처리 코어의 수**이다.　   
각 CPU 코어는 독립적으로 명령어를 실행하고 처리 작업을 수행할 수 있는 중앙 처리 장치의 핵심 부분이다.　   
　   
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/6c322712-d8b4-4505-9e63-55ded8038a0b)　   
=> **내 Windows의 "물리 CPU 코어 개수"는 6개이다.**　 　   
=> **"논리 CPU 코어 개수"는 12개이다!** (아래에서 자세히 보도록 하자)　  　    
　   
이렇게 다중 코어 CPU를 사용하면, 아래와 같은 이점이 있다.　   
**병렬 처리: 다수의 작업을 동시에 처리하여 작업의 처리 속도를 향상**　   
**멀티스레딩: 멀티스레딩 애플리케이션에서 병렬 스레드를 동시에 실행하여 성능 향상, 다중 작업 가능**　   
　   
　   
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/b9da98bb-785d-4a83-bf77-0e17bb3af1a8)　   
=> 이 사진은, 내 Windows 내부의 WSL2를 이용하여 사용하는 Ubuntu(linux 서버)에서 CPU 코어 개수이다.  12개이다.　   
이 수치는 Windows 내부에서 돌아가므로, **가상 CPU 코어 개수**를 나타낸다.　   
　   
**ⓐ 분명 Ubuntu는 Windows 내부에서 돌아가므로, Windows의 코어 개수인 6개를 넘으면 안되는데, 어떻게 2배인 12개가 되는 것일까?**　  
**ⓑ 내 Windows의 물리 CPU코어 개수와, 논리 CPU 코어 개수는 왜 분리되어 있으며 2배 차이일까?"**　  
　   
=> 이 2개의 질문에 의한 답은 같다. 　  
   이는 **HyperThreading** 기술이 적용되었기 때문이다. 바로 아래에서 자세히 보도록 하자.　   
　   
　   
> HyperThreading

![image](https://github.com/inpink/CS_Database_Study/assets/108166692/7915c739-6300-4cde-9e46-15eaaaef0ab4)　   
하이퍼스레딩(Hyper-Threading, HT)은 인텔(Intel)이 개발한 하드웨어 기술로,　   
**하나의 물리적 CPU 코어에서 여러 개의 가상 스레드를 동시에 실행하도록 하는 기술**이다.　   
　   
하이퍼스레딩은 각 물리적 CPU 코어에 여러 개의 가상 스레드를 생성하여　   
이러한 가상 스레드는 운영 체제와 애플리케이션에게 마치 별도의 물리적 CPU 코어인 것처럼 보이게 한다.　   
그래서 Windows 내부에서 돌아가는 Ubuntu의 CPU 코어 개수가 2배인 12개로 사용되는 것이다.　   
　   
　   
**병렬 처리**　  
   : 하이퍼스레딩은 여러 가상 스레드가 동시에 실행될 수 있어서, 다중 작업 및 멀티태스킹 작업에 유용하다. 　   　   
      =>  하이퍼스레딩을 사용하면 일부 작업에서 더 빠른 응답 시간과 성능 향상을 얻을 수 있지만,　   
      모든 종류의 작업에서 성능 향상을 보장하는 것은 아니다.　   
      특히 하이퍼스레딩은 **멀티스레딩 및 병렬 작업**에 더 큰 이점을 제공한다.　   
　   
　   　   
   : 반대로, 단점도 있다.　   
    **다중 작업이 아닌 하나의 큰 작업을 해야할 때는, 하이퍼스레딩의 성능 향상을 느끼기 어렵다.**　   
    오히려 **더 많이 분할된 CPU 코어들이 서로 경쟁**하는 등 오버헤드로 성능 저하를 유발할 수 있다. 　   

　   
　   
![image](https://github.com/inpink/CS_Database_Study/assets/108166692/1d0ae188-5710-4169-b608-ad748812667d)　   
=> Ubuntu에서도, 물리 CPU 코어 개수를 출력하면 6개로 잘 나오는 것을 확인할 수 있다.　 

즉, Windows든, 내부의 Ubuntu든, 물리 CPU 코어 개수는 6개, 논리 CPU 코어 개수는 12개인 것을 확인할 수 있다.　   
내 노트북의 CPU인 Intel i7-9750H는 하이퍼스레딩이 적용된다는 것을 알 수 있었다.　   
　   
intel 공식 홈페이지에서 하이퍼스레딩과 관련된 내용을 확인할 수 있다.　   
https://www.intel.com/content/www/us/en/gaming/resources/hyper-threading.html　   
