# InnoDB 스토리지 엔진 아키텍처

![image](https://github.com/inpink/CS_Database_Study/assets/108166692/31dbc962-b940-486c-8d83-4feced3e2d20)　   
[사진 출처 : MySQL Doc](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)　   
=> InnoDB의 아키텍처이다. 각 요소들을 자세히 살펴보자.　   
　   
　   
> 프라이머리 키에 의한 클러스터링

InnoDB의 테이블들은 기본적으로 **프라이머리 키 값 순서대로 디스크에 저장**된다. 　   
프라이머리 키를 "클러스터링 인덱스"로 사용하는 것이다.　   
세컨더리 인덱스를, **레코드의 주소가 아닌, 프라이머리 키의 "값"을 논리적인 주소**로 사용한다.　   
=> 결과론적으로, 쿼리의 실행 계획에서 다른 보조 인덱스들보다 프라이머리 키의 값이 사용될 가능성이 높아진다. 　   
　   
MyISAM을 포함한 많은 DB에서는 세컨더리 인덱스를 **물리적인 레코드의 주소 값(ROWID)** 으로 사용한다.　   
　   
　   
> 외래 키 지원

이 또한 MyISAM이나 MEMORY 스토리지 엔진에서는 지원하지 않는 기능으로, **외래 키(Foreign Key)** 를 사용할 수 있다.　   
　   
**외래 키는 실제 "서비스용" 데이터베이스에서는 잘 사용하지 않는다.**　   
외래 키로 얽혀 발생하는 문제들을 처리하는 비용보다, 필요할 때마다 Where과 Like절을 이용하여 두 테이블을 엮어 사용하는 비용이 싸기 때문이다.　   
**하지만, "개발" 환경의 DB에서는 외래 키를 쓰는 것이 좋은 가이드 역할이 될 수 있다.**　   
그 이유에 대해서 알아보자.　   
　   
　   
> 외래 키의 장점과 단점

ⓐ 단점 - 유연성 하락　   
  : 외래 키를 사용하면 데이터베이스 간의 관계가 강제되며, 이로 인해 데이터를 조작하는 데 일부 제약이 생긴다.　   
  현실적으로 서비스하는 DB에서는 때로는 관계를 자유롭게 조정해야 할 수 있다.　   
　   
ⓑ 단점 - 성능 저하　   
  : 외래 키를 사용하면 데이터베이스 연산에 부담을 줄 수 있다.　   
  외래 키를 유지하려면 삽입, 갱신 및 삭제 작업에 대한 추가 검증 및 인덱스 유지 관리 작업이 필요하기 때문이다.　   
　   
ⓒ 단점 - 잠금 전파와 데드락(교착상태)　   
  : 외래 키는 부모 테이블과 자식 테이블 모두 해당 column에 인덱스를 생성해야 하고, 이 column와 관련된 작업을 할 때 부모와 자식 모두의 데이터를 확인해줘야 한다. 　   
  따라서 잠금이 여러 테이블로 전파되고, 이로 인해 데드락(교착상태)에 빠질 가능성이 증가한다.　   
　   
ⓓ 단점 - 확장성 제한　   
  : 특히 대규모 애플리케이션에서는 데이터베이스 확장성이 중요하다.　   
  외래 키를 많이 사용하면 데이터베이스의 확장성이 제한되기에 더 많은 서버 또는 클러스터를 도입하는 것이 더 어려워질 수 있다.　   
　   
ⓔ 장점 - 개발 환경에서의 가이드 역할　   
  : 위와 같은 단점을 가지기에 서비스 환경 DB에서는 외래 키를 잘 사용하지 않지만,　   
  개발 환경에서 외래 키를 사용하는 것은 데이터의 일관성을 유지하고 데이터 모델링의 가이드의 역할을 하기도 한다.　   
  설계하고 구현, 작업하는 단계에서 외래 키는 데이터베이스에서 정확한 관계를 설정하고 관계를 유지하는 데 도움이 된다.　   
  데이터의 무결성을 유지하고 데이터 모델링의 실수를 방지할 수 있다.　   
  　   
=> 이러한 이유로 개발 환경에서는 주로 외래 키를 사용하고, 프로덕션 환경에서는 성능 및 확장성을 고려하여 외래 키 사용을 줄이는 것이 일반적이다.　   
　   
　   
　   
> 외래 키 체크 작업 일시 중단

MySQL에서는 **foreign_key_checks** 시스템 변수를 OFF로 하여, **외래 키에 대한 체크 작업을 잠시 중단할 수 있다.**　   
　   
~~~
SET foreign_key_checks=OFF;
~~~
=> 이 상태에서 외래 키가 적용된 column에 변경이 일어났다면, 추후 부모와 자식 테이블간의 foreign 관계를 제대로 맞추는 수정 작업이 필요하다. 　   
　   
　   
> 잠금(locking)과 데드락(deadlock, 교착상태)

💙 잠금 (Locking)　   
  : DB에서 여러 트랜잭션이 동시에 데이터를 읽거나 수정하려고 할 때 충돌을 방지하기 위해 잠금 메커니즘이 사용된다.　   
  트랜잭션이 데이터를 읽거나 수정할 때 해당 데이터를 잠금 상태로 설정하며, 이 때 다른 트랜잭션이 해당 데이터를 변경할 수 없다.　   
  　   
💙 데드락 (Deadlock)　   
  : 두 개 이상의 트랜잭션이 서로의 잠금을 기다리며 무한히 진행하지 못하는 상황.　   
  예를 들어, 트랜잭션 A가 데이터 X에 잠금을 얻고, 트랜잭션 B가 데이터 Y에 잠금을 얻는 경우, 트랜잭션 A는 데이터 Y의 잠금을 기다리고, 트랜잭션 B는 데이터 X의 잠금을 기다린다. 이 때 어떤 트랜잭션도 진행되지 못하고 대기 상태에 빠진다. 　   
  "교착상태"라고도 한다.　   
　   
　   

