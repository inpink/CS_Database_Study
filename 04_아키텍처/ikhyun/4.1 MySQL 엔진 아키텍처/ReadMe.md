## MySQL 엔진 아키택처
## MySQL의 전체 구조
![MySQL 서버의 전체 구조](./images/MySQL%20서버의전체%20구조.jpg)
- MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분 할수 있다.

### MySQL 엔진
- 커넥션 핸들러와 옵티마이저 중심으로 이루어진다.
  - 커넥션 핸들러: 클라이언트로 부터 접속및 쿼리 요청 처리
  - 옵티마이저:  쿼리 최적화 실행
- 표준 SQL문법을 지원하기 때문에 타 DBMS와 호환이 됨

### 스토리지 엔진
- 실제 데이터를 저장하거나 읽어는것을 담당
- 여러개의 스토리지 엔진을 동시에 사용 가능

### 핸들러 API
- 핸들러 요청: MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기 요청 함
- 핸들러 요청에 사용되는 API를 핸들러 API라고 한다.
- SHOW GLOBAL STATUS LIKE 'Handler%'; 명령어로 핸들러 API 작업을 알수 있다.

## MySQL 스레딩 구조
![MySQL 스레딩 구조](./images/MySQL%20스레딩%20구조.jpg)
- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동됨
- 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있음
- MySQL 서버에서 실행 중인 목록은 performance_schema 데이터베이스의 threads 테이블 통해 확인할 수 있다.
```SQL
    SELECT thread_id, name, type, processlist_user, processlist_host
    from performance_schema.threads ORDER BY type, thread_id;
  ```
  
### 포그라운드 스레이(클라이언트 스레드)
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 커넥션 담당하는 스레드는 스레드 캐시로 되돌아 간다.
- 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으며 스레드 캐시에 넣지 않고 스레드를 종료 시켜서 일정개수만 스레드만 스레드 캐시에 존재한다.
- 최대 스레드 개수는 thread_cache_size 시스템 변수로 저장한다.
- 데이터를 데이터 버퍼나 캐시로 가져온다.
- 데이터 버퍼나 캐시가 없을 경우 디스크의 데이터나 인덱스 파일로 부터 데이터를 읽어와서 작업을 처리한다.
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
- InnoDB 테이블은 데이터 버퍼까지만 포그라운드 스레드가 처리한다.

###  백그라운드 스레드
- InnoDB는 아래 작업을 처리한다.
  - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  - **로그를 디스크로 기록하는 스레드(★)**
  - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드(★)**
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잡금이나 데드락을 모르니터링하는 스레드
- MySQL 5.5 버전 부터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정 가능
- innodb_write_io_threads, innodb_read_io_threads 시스템 변수로 개수 설정
- InnoDB는 읽기 작업은 지연될수 없어서 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있음(데이터 변경후 파일로 저장 될 때까지 기다리지 않아도 됨)
- MyISAM은 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계됨, 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할수 없다.

## 메모리 할당 및 사용 구조
![MySQL의 메모리 사용 및 할당구조](./images/MySQL의%20메모리%20사용%20및%20할당%20구조.jpg)
- 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 나누어 진다.
  
### 글로벌 메모리 영역
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 로컬 메모리 영역
- 세션 메모리 영역, 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
- 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용하지 않는다.
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수 있다.
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간(커넥션 버퍼나 결과 버퍼)
- 쿼리를 실행하는 순에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)
- 대표적인 로컬 메모리 영역
  - 정렬 버퍼(Sort buffer)
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델
![MySQL의 플러그인 모델](./images/MySQL%20플러그인%20모델.png)
- MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델이다.
- 전문 검색 엔진을 위한 검색어 파서(인덱싱할 키워드를 분리해내는 작업), 사용자의 인증을 위한 Native Authentication과 Caching SHA-2 Authenication등도 모두 플러그인으로 구현되어 제공한다.
- 수많은 사용자의 요구 조건을 만족시키기 위해 기본적으로 제공되는 스토리지 엔진 외에 부가적인 기능을 더 제공하는 스토리지 엔진을 개발하여 플러그인 형태로 제공할 수 있다. 따라서 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워 넣기만 하면 손쉽게 부가적인 기능도 사용할 수 있게 된다.
- MySQL 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원한다.
- 인증이나 전문 검색 파서 또는 쿼리 재작성과 같은 플러그인이 있으며, 비밀번호 검증과 커넥션 제어 등에 관련된 다양한 플러그인이 제공된다. 이뿐만 아니라 MySQL 서버의 기능을 커스텀하게 확장하거나 새로운 기능을 플러그인을 이용해 구현할 수도 있다.

## 컴포넌트
- 플러그인의 아래의 단점을 보완해서 구현됨
  -  플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
  -  플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
  -  플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
  -  MySQL 5.7버전까지 비밀번호 검증 기능이 플러그인 형태로 제공 MySQL8.0의 비밀번호 검증 기능은 컴포넌트로 개선됨

## 쿼리 실행 구조
![쿼리 실행구조](./images/쿼리%20실행%20구조.png)

### 쿼리파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업
- 쿼리 문장의 기본 문법 오류는 이과정에서 발견되고 오류 메시지를 전달하게 된다.

### 전처리기
- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
-  각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행

### 옵티마이저(두뇌담당)
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역활을 담당

### 실행엔진(손과 발 담당)
- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역활을 수행한다.
- 과정  
  1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
  2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
  3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 핸들러(스토리지 엔진)
- MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역활을 담당
- MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 됨
- InnoDB 테이블을 조작하는 경우에는 핸들러가 InnoDB 스토리지 엔진이 됨

## 쿼리 캐시

## 스레드 풀
- 정작 커뮤니티 에디션엔 없음
- 일반적인 서버에서의 스레드 풀과 유사함

## 트랜잭션 지원 메타데이터
- 데이터베이스 서버에서 테이블의 구조 정보와 Stored Program 등의 정보를 데이터 딕셔너리/메타데이터라고 함.
- 5.7 까지는 구조를 FRM 파일에 저장하고 일부 Stored Program 의 정보 또한 파일로 저장함.
  - 다만, 이런 구조는 트랜잭션을 지원하지 않았기에 생성 도중에 문제가 생기면 정합성에 문제가 생김
- 8.0 부터는 테이블의 구조 정보나 Stored Program의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선됨.
- 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql 이라는 이름의 DB에 저장하며, 이 DB의 정보는 mysql.ibd 라는 이름의 테이블 스페이스에 저장됨.
  - 그렇기에 해당 파일은 잘 관리해야 함!
  - 참고로, 데이터 딕셔너리는 저장은 되지만 사용자의 임의 수정을 막기 위해 테이블을 보여주지 않으며, 대신  information_schema DB의 TABLES/COLUMNS 등과 같은 뷰를 통해서 조회할 수 있도록 함.
- 또한 테이블에 대해 접근을 시도하면 권한이 없다고 뜸
- 물론 InnoDB를 사용한다고 해도, 다른 스토리지 엔진의 메타 정보는 다른데다 저장해야 함.
- MySQL 서버는 InnoDB 엔진 이외의 스토리지 엔진을 사용하는 테이블을 위해 SDI (Serialized Dictionary Information) 파일을 사용하는데, 이는 기존의 FRM 파일과 동일한 역할을 함.